<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elixir | devblog of @sgt_mactavish]]></title>
  <link href="http://brain64bit.github.io/blog/categories/elixir/atom.xml" rel="self"/>
  <link href="http://brain64bit.github.io/"/>
  <updated>2015-08-19T23:39:38+07:00</updated>
  <id>http://brain64bit.github.io/</id>
  <author>
    <name><![CDATA[@sgt_mactavish]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir Functional Form]]></title>
    <link href="http://brain64bit.github.io/blog/2015/07/11/elixir-functional-form/"/>
    <updated>2015-07-11T00:39:18+07:00</updated>
    <id>http://brain64bit.github.io/blog/2015/07/11/elixir-functional-form</id>
    <content type="html"><![CDATA[<p>I am still exploring Elixir anonymous function, let&rsquo;s move on to another interesting feature. Like javascript or functional programming language, in Elixir we can writes function that <strong>takes one or more functions as an input</strong> and or <strong>returns a function</strong>,</p>

<p>```elixir
iex(1)> passed_func = fn(a) &ndash;> a + 3 end</p>

<h1>Function&lt;6.90072148/1 in :erl_eval.expr/5></h1>

<p>iex(2)> apply_func = fn(func_arg, num) &ndash;> func_arg.(func_arg.(num)) end</p>

<h1>Function&lt;12.90072148/2 in :erl_eval.expr/5></h1>

<p>iex(3)> apply_func.(passed_func, 7)
13
iex(4)>
```
We have <strong>passed_func</strong> which is a function that returns a function, and <strong>apply_func</strong> which is takes function as an argument. Inside apply_func we apply passed_func twice.</p>

<!--MORE-->


<p>Like Ruby, inside Elixir Enum module has a function called map which has the same purpose, different with Ruby, in Elixir the map function takes two arguments, first is a collection and second is a function.</p>

<p><strong>ruby way:</strong></p>

<p><code>ruby
irb(main):001:0&gt; list = [1,2,3,4,5]
=&gt; [1, 2, 3, 4, 5]
irb(main):002:0&gt; list.map{|el| el * 2}
=&gt; [2, 4, 6, 8, 10]
irb(main):003:0&gt;
</code></p>

<p><strong>elixir way</strong></p>

<p><code>elixir
iex(5)&gt; list = [1,2,3,4,5]
[1, 2, 3, 4, 5]
iex(6)&gt; Enum.map list, fn(el) -&gt; el * 2 end
[2, 4, 6, 8, 10]
iex(7)&gt;
</code></p>

<h2>The &amp; Shortcut</h2>

<p>Again like a Ruby, Elixir has &amp; operator to write short function. The body of the function surrounded by ( and ), and the the placeholders &amp;1, &amp;2, and so on correspond to the first, second, and subsequent parameters of the function.</p>

<p><code>elixir
iex(2)&gt; add = &amp;(&amp;1 + &amp;2)
&amp;:erlang.+/2
iex(3)&gt; add.(9, 4)
13
iex(4)&gt;
</code>
This shortcut function can be applied in map function:</p>

<p><strong>ruby way</strong></p>

<p><code>ruby
irb(main):009:0&gt; list = %w&lt;a b c d e&gt;
=&gt; ["a", "b", "c", "d", "e"]
irb(main):010:0&gt; list.map(&amp;:upcase)
=&gt; ["A", "B", "C", "D", "E"]
irb(main):011:0&gt;
</code></p>

<p><strong>elixir way</strong></p>

<p><code>elixir
iex(7)&gt; list = ["a", "b", "c", "d", "e"]
["a", "b", "c", "d", "e"]
iex(8)&gt; Enum.map list, &amp;(String.upcase(&amp;1))
["A", "B", "C", "D", "E"]
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir Anonymous Function]]></title>
    <link href="http://brain64bit.github.io/blog/2015/07/03/elixir-anonymous-function/"/>
    <updated>2015-07-03T01:08:21+07:00</updated>
    <id>http://brain64bit.github.io/blog/2015/07/03/elixir-anonymous-function</id>
    <content type="html"><![CDATA[<p>In Elixir we can create anonymous function like in javascript, use <strong>fn</strong> keyword to define an anonymous function.</p>

<p>```elixir
fn
  parameters &ndash;> body
end</p>

<p>fn (parameters) &ndash;> body end
<code>``
Variable can be assigned by anonymous function, and you can call it using</code>variable_name.(arg1, arg2)` for example, below is a simple anonymous function that bind into a variable.</p>

<!--MORE-->


<p><code>elixir
velocity = fn(distance, time) -&gt; distance / time end
IO.puts "Speed of light is #{velocity.(600_000_000, 2)}"
</code></p>

<h2>Function &amp; Pattern Matching</h2>

<p>Pattern matching can be applied in function, we can use pattern matching in function argument to determine which implementation to run. For example lets use tuple for argument.</p>

<p>```elixir
say = fn
  {:en, name} &ndash;> IO.puts &ldquo;Hello #{name}&rdquo;
  {:id, name} &ndash;> IO.puts &ldquo;Halo #{name}&rdquo;
end</p>

<p>say.({:id, &lsquo;Max&rsquo;})
say.({:en, &lsquo;Rockatansky&rsquo;})
```
Please try and guess what the output of the example above. The tuple structure in function argument determines which implementation will be executed. It&rsquo;s like one function with multiple bodies. Now lets implement fizz-buzz without conditional but using pattern matching:</p>

<p>```elixir
fizz_buzz = fn
  {0, 0, <em>} &ndash;> IO.puts &ldquo;FizzBuzz&rdquo;
  {0, </em>, <em>} &ndash;> IO.puts &ldquo;Fizz&rdquo;
  {</em>, 0, <em>} &ndash;> IO.puts &ldquo;Buzz&rdquo;
  {</em>, _, n} &ndash;> IO.puts n
end</p>

<p>is_fizz_buzz = fn
  (n) &ndash;> fizz_buzz.({rem(n,3), rem(n,5), n})
end</p>

<p>is_fizz_buzz.(10)
is_fizz_buzz.(11)
is_fizz_buzz.(12)
is_fizz_buzz.(13)
is_fizz_buzz.(14)
is_fizz_buzz.(15)
is_fizz_buzz.(16)
```
Can you guess what the output is?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir Pattern Matching]]></title>
    <link href="http://brain64bit.github.io/blog/2015/07/02/elixir-pattern-matching/"/>
    <updated>2015-07-02T22:27:48+07:00</updated>
    <id>http://brain64bit.github.io/blog/2015/07/02/elixir-pattern-matching</id>
    <content type="html"><![CDATA[<p>In Elixir pattern matching can be done using <strong>=</strong> operator, the equal sign compares left-hand side variable with right-hand side variable, it&rsquo;s success if both are equal. Lets see simple example:</p>

<p>```elixir
iex(1)> foo = &lsquo;bar&rsquo;
&lsquo;bar&rsquo;
iex(2)> &lsquo;bar&rsquo; = foo
&lsquo;bar&rsquo;
iex(3)> &lsquo;baz&rsquo; = foo
** (MatchError) no match of right hand side value: &lsquo;bar&rsquo;</p>

<p>iex(3)> foo = &lsquo;baz&rsquo;
&lsquo;baz&rsquo;
iex(4)> &lsquo;baz&rsquo; = foo
&lsquo;baz&rsquo;
```</p>

<!--MORE-->


<p><code>'bar' = foo</code> is valid because both left &amp; right side are equal to &lsquo;bar&rsquo;. But in the line 3, when the sides don&rsquo;t match it&rsquo;s raise <strong>MatchError</strong>. From above example, variable can only be assigned on the left side.</p>

<p>```elixir
iex(10)> list = [1,[2,3],4]
[1, [2, 3], 4]
iex(11)> [x,y,z] = list
[1, [2, 3], 4]
iex(12)> y = [2,3]
[2, 3]
iex(13)> [2,4] = y
** (MatchError) no match of right hand side value: [2, 3]</p>

<p>iex(13)> x
1
iex(14)> z
4
iex(15)>
```
A pattern (the left side) is matched if the values (the right side) have the same structure and if each term in the pattern can be matched to the corresponding term in the values.</p>

<p>Also, you can ignoring a value when assignment with <strong>underscore</strong> operator &lsquo;_&rsquo;. It&rsquo;s useful when we didn&rsquo;t need to capture a value during assignment.</p>

<p><code>elixir
iex(19)&gt; [a, _] = [1, 2]
[1, 2]
iex(20)&gt; a
1
iex(21)&gt;
</code>
Another feature that exist in elixir pattern matching is <strong>caret</strong> ^ operator. It&rsquo;s useful if you want to force to Elixir to use existing value or you don&rsquo;t want to rebinding a variable. Just prefix a variable with ^ to use existing value.</p>

<p><code>elixir
iex(30)&gt; z = 5
5
iex(31)&gt; [^z, 6] = [5, 6]
[5, 6]
iex(32)&gt;
</code>
<strong>Ref:</strong></p>

<ul>
<li><a href="http://elixir-lang.org/getting-started/pattern-matching.html">Elixir Pattern Matching</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
