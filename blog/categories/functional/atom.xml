<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional | devblog of @sgt_mactavish]]></title>
  <link href="http://brain64bit.github.io/blog/categories/functional/atom.xml" rel="self"/>
  <link href="http://brain64bit.github.io/"/>
  <updated>2015-07-11T00:52:15+07:00</updated>
  <id>http://brain64bit.github.io/</id>
  <author>
    <name><![CDATA[@sgt_mactavish]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir Functional Form]]></title>
    <link href="http://brain64bit.github.io/blog/2015/07/11/elixir-functional-form/"/>
    <updated>2015-07-11T00:39:18+07:00</updated>
    <id>http://brain64bit.github.io/blog/2015/07/11/elixir-functional-form</id>
    <content type="html"><![CDATA[<p>I am still exploring Elixir anonymous function, let&rsquo;s move on to another interesting feature. Like javascript or functional programming language, in Elixir we can writes function that <strong>takes one or more functions as an input</strong> and or <strong>returns a function</strong>,</p>

<p>```elixir
iex(1)> passed_func = fn(a) &ndash;> a + 3 end</p>

<h1>Function&lt;6.90072148/1 in :erl_eval.expr/5></h1>

<p>iex(2)> apply_func = fn(func_arg, num) &ndash;> func_arg.(func_arg.(num)) end</p>

<h1>Function&lt;12.90072148/2 in :erl_eval.expr/5></h1>

<p>iex(3)> apply_func.(passed_func, 7)
13
iex(4)>
```
We have <strong>passed_func</strong> which is a function that returns a function, and <strong>apply_func</strong> which is takes function as an argument. Inside apply_func we apply passed_func twice.</p>

<!--MORE-->


<p>Like Ruby, inside Elixir Enum module has a function called map which has the same purpose, different with Ruby, in Elixir the map function takes two arguments, first is a collection and second is a function.</p>

<p><strong>ruby way:</strong></p>

<p><code>ruby
irb(main):001:0&gt; list = [1,2,3,4,5]
=&gt; [1, 2, 3, 4, 5]
irb(main):002:0&gt; list.map{|el| el * 2}
=&gt; [2, 4, 6, 8, 10]
irb(main):003:0&gt;
</code></p>

<p><strong>elixir way</strong></p>

<p><code>elixir
iex(5)&gt; list = [1,2,3,4,5]
[1, 2, 3, 4, 5]
iex(6)&gt; Enum.map list, fn(el) -&gt; el * 2 end
[2, 4, 6, 8, 10]
iex(7)&gt;
</code></p>

<h2>The &amp; Shortcut</h2>

<p>Again like a Ruby, Elixir has &amp; operator to write short function. The body of the function surrounded by ( and ), and the the placeholders &amp;1, &amp;2, and so on correspond to the first, second, and subsequent parameters of the function.</p>

<p><code>elixir
iex(2)&gt; add = &amp;(&amp;1 + &amp;2)
&amp;:erlang.+/2
iex(3)&gt; add.(9, 4)
13
iex(4)&gt;
</code>
This shortcut function can be applied in map function:</p>

<p><strong>ruby way</strong></p>

<p><code>ruby
irb(main):009:0&gt; list = %w&lt;a b c d e&gt;
=&gt; ["a", "b", "c", "d", "e"]
irb(main):010:0&gt; list.map(&amp;:upcase)
=&gt; ["A", "B", "C", "D", "E"]
irb(main):011:0&gt;
</code></p>

<p><strong>elixir way</strong></p>

<p><code>elixir
iex(7)&gt; list = ["a", "b", "c", "d", "e"]
["a", "b", "c", "d", "e"]
iex(8)&gt; Enum.map list, &amp;(String.upcase(&amp;1))
["A", "B", "C", "D", "E"]
</code></p>
]]></content>
  </entry>
  
</feed>
